import {
  l,
  n
} from "./chunk-MPF4V6QH.js";
import "./chunk-V6TY7KAL.js";

// node_modules/@swup/plugin/dist/index.modern.js
function r() {
  return r = Object.assign ? Object.assign.bind() : function(r3) {
    for (var n4 = 1; n4 < arguments.length; n4++) {
      var e2 = arguments[n4];
      for (var t in e2) Object.prototype.hasOwnProperty.call(e2, t) && (r3[t] = e2[t]);
    }
    return r3;
  }, r.apply(this, arguments);
}
var n2 = (r3) => String(r3).split(".").map((r4) => String(parseInt(r4 || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
var e = class {
  constructor() {
    this.isSwupPlugin = true, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [];
  }
  mount() {
  }
  unmount() {
    this.handlersToUnregister.forEach((r3) => r3()), this.handlersToUnregister = [];
  }
  _beforeMount() {
    if (!this.name) throw new Error("You must define a name of plugin when creating a class.");
  }
  _afterUnmount() {
  }
  _checkRequirements() {
    return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r3, e2]) => {
      if (!function(r4, e3, t) {
        const s = function(r5, n4) {
          var e4;
          if ("swup" === r5) return null != (e4 = n4.version) ? e4 : "";
          {
            var t2;
            const e5 = n4.findPlugin(r5);
            return null != (t2 = null == e5 ? void 0 : e5.version) ? t2 : "";
          }
        }(r4, t);
        return !!s && ((r5, e4) => e4.every((e5) => {
          const [, t2, s2] = e5.match(/^([\D]+)?(.*)$/) || [];
          var o2, i2;
          return ((r6, n4) => {
            const e6 = { "": (r7) => 0 === r7, ">": (r7) => r7 > 0, ">=": (r7) => r7 >= 0, "<": (r7) => r7 < 0, "<=": (r7) => r7 <= 0 };
            return (e6[n4] || e6[""])(r6);
          })((i2 = s2, o2 = n2(o2 = r5), i2 = n2(i2), o2.localeCompare(i2, void 0, { numeric: true })), t2 || ">=");
        }))(s, e3);
      }(r3, e2 = Array.isArray(e2) ? e2 : [e2], this.swup)) {
        const n4 = `${r3} ${e2.join(", ")}`;
        throw new Error(`Plugin version mismatch: ${this.name} requires ${n4}`);
      }
    }), true;
  }
  on(r3, n4, e2 = {}) {
    var t;
    n4 = !(t = n4).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n4.bind(this) : n4;
    const s = this.swup.hooks.on(r3, n4, e2);
    return this.handlersToUnregister.push(s), s;
  }
  once(n4, e2, t = {}) {
    return this.on(n4, e2, r({}, t, { once: true }));
  }
  before(n4, e2, t = {}) {
    return this.on(n4, e2, r({}, t, { before: true }));
  }
  replace(n4, e2, t = {}) {
    return this.on(n4, e2, r({}, t, { replace: true }));
  }
  off(r3, n4) {
    return this.swup.hooks.off(r3, n4);
  }
};

// node_modules/@swup/preload-plugin/dist/index.modern.js
function r2() {
  return r2 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t = 1; t < arguments.length; t++) {
      var s = arguments[t];
      for (var r3 in s) Object.prototype.hasOwnProperty.call(s, r3) && (e2[r3] = s[r3]);
    }
    return e2;
  }, r2.apply(this, arguments);
}
function o() {
  return window.matchMedia("(hover: hover)").matches;
}
function i(e2) {
  return !!e2 && (e2 instanceof HTMLAnchorElement || e2 instanceof SVGAElement);
}
var n3 = window.requestIdleCallback || ((e2) => setTimeout(e2, 1));
var a = ["preloadVisibleLinks"];
var l2 = class extends e {
  constructor(e2 = {}) {
    var s;
    super(), s = this, this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: true, preloadHoveredLinks: true, preloadVisibleLinks: { enabled: false, threshold: 0.2, delay: 500, containers: ["body"], ignore: () => false } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = /* @__PURE__ */ new Map(), this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e3, t, s2) => {
      const { url: r3 } = e3.to;
      return r3 && this.preloadPromises.has(r3) ? this.preloadPromises.get(r3) : s2(e3, t);
    }, this.onMouseEnter = async function(e3) {
      if (e3.target !== e3.delegateTarget) return;
      if (!o()) return;
      const r3 = e3.delegateTarget;
      if (!i(r3)) return;
      const { url: n5, hash: a2 } = l.fromElement(r3), l4 = s.swup.createVisit({ to: n5, hash: a2, el: r3, event: e3 });
      s.swup.hooks.callSync("link:hover", l4, { el: r3, event: e3 }), s.preload(r3, { priority: true });
    }, this.onTouchStart = (e3) => {
      if (o()) return;
      const t = e3.delegateTarget;
      i(t) && this.preload(t, { priority: true });
    }, this.onFocus = (e3) => {
      const t = e3.delegateTarget;
      i(t) && this.preload(t, { priority: true });
    };
    const { preloadVisibleLinks: n4 } = e2, l3 = function(e3, t) {
      if (null == e3) return {};
      var s2, r3, o2 = {}, i2 = Object.keys(e3);
      for (r3 = 0; r3 < i2.length; r3++) t.indexOf(s2 = i2[r3]) >= 0 || (o2[s2] = e3[s2]);
      return o2;
    }(e2, a);
    this.options = r2({}, this.defaults, l3), "object" == typeof n4 ? this.options.preloadVisibleLinks = r2({}, this.options.preloadVisibleLinks, { enabled: true }, n4) : this.options.preloadVisibleLinks.enabled = Boolean(n4), this.preload = this.preload.bind(this), this.queue = /* @__PURE__ */ function(e3 = 1) {
      const t = [], s2 = [];
      let r3 = 0, o2 = 0;
      function i2() {
        o2 < e3 && r3 > 0 && ((s2.shift() || t.shift() || (() => {
        }))(), r3--, o2++);
      }
      return { add: function(e4, o3 = false) {
        if (e4.__queued) {
          if (!o3) return;
          {
            const s3 = t.indexOf(e4);
            if (s3 >= 0) {
              const e5 = t.splice(s3, 1);
              r3 -= e5.length;
            }
          }
        }
        e4.__queued = true, (o3 ? s2 : t).push(e4), r3++, r3 <= 1 && i2();
      }, next: function() {
        o2--, i2();
      } };
    }(this.options.throttle);
  }
  mount() {
    const e2 = this.swup;
    e2.options.cache ? (e2.hooks.create("page:preload"), e2.hooks.create("link:hover"), e2.preload = this.preload, e2.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(n())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading");
  }
  unmount() {
    var e2, t, s;
    this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (e2 = this.mouseEnterDelegate) || e2.destroy(), null == (t = this.touchStartDelegate) || t.destroy(), null == (s = this.focusDelegate) || s.destroy(), this.stopPreloadingVisibleLinks();
  }
  async preload(e2, s = {}) {
    var r3;
    let o2, n4;
    const a2 = null != (r3 = s.priority) && r3;
    if (Array.isArray(e2)) return Promise.all(e2.map((e3) => this.preload(e3)));
    if (i(e2)) n4 = e2, { href: o2 } = l.fromElement(e2);
    else {
      if ("string" != typeof e2) return;
      o2 = e2;
    }
    if (!o2) return;
    if (this.preloadPromises.has(o2)) return this.preloadPromises.get(o2);
    if (!this.shouldPreload(o2, { el: n4 })) return;
    const l3 = new Promise((e3) => {
      this.queue.add(() => {
        this.performPreload(o2).catch(() => {
        }).then((t) => e3(t)).finally(() => {
          this.queue.next(), this.preloadPromises.delete(o2);
        });
      }, a2);
    });
    return this.preloadPromises.set(o2, l3), l3;
  }
  preloadLinks() {
    n3(() => {
      Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach((e2) => this.preload(e2));
    });
  }
  preloadLinksOnAttention() {
    const { swup: e2 } = this, { linkSelector: t } = e2.options, s = { passive: true, capture: true };
    this.mouseEnterDelegate = e2.delegateEvent(t, "mouseenter", this.onMouseEnter, s), this.touchStartDelegate = e2.delegateEvent(t, "touchstart", this.onTouchStart, s), this.focusDelegate = e2.delegateEvent(t, "focus", this.onFocus, s);
  }
  preloadVisibleLinks() {
    if (this.preloadObserver) return void this.preloadObserver.update();
    const { threshold: e2, delay: s, containers: r3 } = this.options.preloadVisibleLinks;
    this.preloadObserver = function({ threshold: e3, delay: s2, containers: r4, callback: o2, filter: i2 }) {
      const a2 = /* @__PURE__ */ new Map(), l3 = new IntersectionObserver((e4) => {
        e4.forEach((e5) => {
          e5.isIntersecting ? h(e5.target) : d(e5.target);
        });
      }, { threshold: e3 }), h = (e4) => {
        var r5;
        const { href: i3 } = l.fromElement(e4), n4 = null != (r5 = a2.get(i3)) ? r5 : /* @__PURE__ */ new Set();
        a2.set(i3, n4), n4.add(e4), setTimeout(() => {
          const t = a2.get(i3);
          null != t && t.size && (o2(e4), l3.unobserve(e4), t.delete(e4));
        }, s2);
      }, d = (e4) => {
        var s3;
        const { href: r5 } = l.fromElement(e4);
        null == (s3 = a2.get(r5)) || s3.delete(e4);
      }, u = () => {
        n3(() => {
          const e4 = r4.map((e5) => `${e5} a[*|href]`).join(", ");
          Array.from(document.querySelectorAll(e4)).filter((e5) => i2(e5)).forEach((e5) => l3.observe(e5));
        });
      };
      return { start: () => u(), stop: () => l3.disconnect(), update: () => (a2.clear(), u()) };
    }({ threshold: e2, delay: s, containers: r3, callback: (e3) => this.preload(e3), filter: (e3) => {
      if (this.options.preloadVisibleLinks.ignore(e3)) return false;
      if (!e3.matches(this.swup.options.linkSelector)) return false;
      const { href: s2 } = l.fromElement(e3);
      return this.shouldPreload(s2, { el: e3 });
    } }), this.preloadObserver.start();
  }
  stopPreloadingVisibleLinks() {
    this.preloadObserver && this.preloadObserver.stop();
  }
  shouldPreload(e2, { el: r3 } = {}) {
    const { url: o2, href: i2 } = l.fromUrl(e2);
    return !(!function() {
      if (navigator.connection) {
        var e3;
        if (navigator.connection.saveData) return false;
        if (null != (e3 = navigator.connection.effectiveType) && e3.endsWith("2g")) return false;
      }
      return true;
    }() || this.swup.cache.has(o2) || this.preloadPromises.has(o2) || this.swup.shouldIgnoreVisit(i2, { el: r3 }) || r3 && this.swup.resolveUrl(o2) === this.swup.resolveUrl(n()));
  }
  async performPreload(e2) {
    var s = this;
    const { url: r3 } = l.fromUrl(e2), o2 = this.swup.createVisit({ to: r3 }), i2 = await this.swup.hooks.call("page:preload", o2, { url: r3 }, async function(t, r4) {
      return r4.page = await s.swup.fetchPage(e2, { visit: t }), r4.page;
    });
    return i2;
  }
};
export {
  l2 as default
};
//# sourceMappingURL=@swup_preload-plugin.js.map
